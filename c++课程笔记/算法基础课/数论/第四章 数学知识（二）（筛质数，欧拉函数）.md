 1.欧拉函数
欧拉函数是φ（n）
意思是求1到n中与n互质的数的个数
如φ（6）=1-6中与6互质的数的个数=2

公式：
n=p1的k次方*p2的k次方*p3的k次方*....*pk的k次方		//将n分解质因数
φ（n）=n*（1-1/p1）*(1-1/p2)*(1-1/p3)*....(1-1/pk)		//p与上一个式子中相同

原理：
需要用到容斥原理（先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理）
步骤：
1.从1-n中去掉p1，p2....，pk的所有倍数，p1，p2，p3等均不相等，不考虑个数只考虑有没有出现
n-n/p1-n/p2-n/p3....-n/pk

2.加上所有pi*pj的倍数（因为第一步中多删除了部分倍数，如p1p2的公共倍数等等）
n-n/p1-n/p2-n/p3....-n/pk+n/（p1*p2+n/（p1*p3）+....+n/(pk-1*pk)

3.减去所有pi*pj*pk的倍数
n-n/p1-n/p2-n/p3....-n/pk+n/（p1*p2+n/（p1*p3）+....+n/(pk-1*pk)-n/（p1*p2*p3）-.....
以此类推，这就是容斥原理
随后化简可得φ（n）=n*（1-1/p1）*(1-1/p2)*(1-1/p3)*....(1-1/pk)		//可以列举多个例子来证明如只有p1和p2

时间复杂度为n*根号n

代码实现：
while (n --)
    {
        long long a;
        cin >> a;
        long long res = a;
        for (int i=2;i<=a/i;i++)
        {
            if (a%i==0)
            {
                res = res/i*(i-1);			//因为c++中/号是整除，所以n*（1-1/p1）只能转换成n/p1*（p1-1）
                while (a%i==0) a/=i;		//把a中的i除完
            }
        }
        if (a > 1) res = res/a*(a-1);		//最后可能还会有一个最大的质因数没有添加进去，所以还要再加一个
        cout << res << endl;			
    }


2.筛法求欧拉函数

有些情况下要求每个数的欧拉函数，普通的运用公式时间复杂度较长
这时候要借用线性筛法


代码实现：
#include <iostream>
#include <algorithm>
using namespace std;

typedef long long LL;
const int N = 1000010;

int primes[N],cnt;
int phi[N];
bool st[N];

LL get_eulers(int n)
{
    phi[1] = 1;
    for(int i = 2;i <= n;i ++)
    {
        if(!st[i])    		//如果该数为素数
        {
            primes[cnt ++] = i;
            phi[i] = i - 1;		 	//求质数的欧拉函数，质数的欧拉函数就是质数减一
        }
        for(int j = 0;primes[j] <= n / i;j ++) 			//求出数字为pj*i(倍数)的合数的时候
        {
            st[primes[j] * i] = true;		//避免二次求欧拉函数，即把合数给剔除
            if(i % primes[j] == 0)  		
            {  							//求pj是i的最小质因子时的合数的欧拉函数
                phi[primes[j] * i] = phi[i] * primes[j];		//当pj是i的最小质因子的时候，有一个公式：φ（pj*i）=pj*i*（1-p1）*....(1-pk)=pj*φ（i）
                break;
            }					//求pj不是i质数的合数的欧拉函数，pj * i仍然是一个合数,pj为他的质数时
            					//它仍然要被标记为pj的倍数	
            else phi[primes[j] * i] = (primes[j] - 1) * phi[i];			当pj不是i的最小质因子的时候，公式：φ（pj*i）=pj*φ（i）*（1-1/pj）因为c++中没有除法只有整除，所以可以化简成φ（pj*i）=φ（i）*（pj-1）
        }
    }
}

int main()
{
    int n;
    cin >> n;
    get_eulers(n);

    LL res = 0; //注意res为long long，不然会爆int，变成负数
    for(int i = 1;i <= n;i ++)res += eulers[i];

    cout << res << endl;

    return 0;

}



同余定理：
若a==b（mod n）  c==d（mod n）  可以推出 a±c==b±d（mod n）    a*c==b*d（mod n）		a**u==b**u（mod n）			a*b%m=(a%m)*(b%m)%m


费马-欧拉定理：
若a与n互质：
a是一个数
则会有a的φ（n）%n==1即a^φ（n）mod （n）==1
φ（n）是1-n中所有与n互质的数的个数
证明：
则1-n中
所有和n互质的数有a1,a2，a3，a4.......，aφ（n）
那么就有a*a1，a*a2，a*a3，......，a*aφ（n）
二者mod（n）相同，是在同一个剩余系中即：a*a1%n，a*a2%n，....，a*an%n这个剩余系和上一个剩余系中的数应该是完全相同的，但是顺序不同，所以说是相等
如1,2,3,4
2,4,6,8两式对5取模则有2,4,1,3
因此就有上一个式子的乘积对n取模和下一个式子的乘积对n取模二者完全相同，然后将a的φ（n）次方提出来
就可以得出a^φ（n）mod （n）==1


快速幂：
将高阶的幂通过欧拉函数，将幂数转换成2进制的低幂数相加，然后取模的值相乘后再取模

原理：
如求4^5mod（10）
4^(2^0)==4(mod 10)
4^(2^1)==6(mod 10)
4^(2^2)==6(mod 10)
5=2^0+2^2

第一项a^1=a^(2^0)
第二项a^(2^1)=a^((2^0))^2
第三项a^(2^2)=a^((2^2))^2
....
第log2（k）+1项a^(2^log2(k))=(a^( 2^  (log2(k)) -1 ) )^2
每一个数都是上一个数的平方（mod p）
取余定理：乘法 a*b%m=(a%m)*(b%m)%m

所以4^5(mod 10)=4^(2^0)*4^(2^2)(mod 10)=4*6( mod 10)==4 (mod 10)
时间复杂度为log2（k）

代码实现：

